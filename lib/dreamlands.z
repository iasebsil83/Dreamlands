/* .----------------- DREAMLANDS Z Library [0.1.0] ---------------.
   |                                                              |
   |     This library is the official parser tool for DREAMLANDS  |
   | files. It includes 4 functions :                             |
   |   - Dreamlands.fromText() get data from raw text             |
   |   - Dreamlands.toText()   get raw text from data             |
   |   - Dreamlands.read()     get data from file                 |
   |   - Dreamlands.write()    write data into file               |
   |                                                              |
   |     For more information about this syntax, please check     |
   | out the main repository for documentation:                   |
   |                                                              |
   |           https://github.com/iasebsil83/DREAMLANDS           |
   |                                                              |
   | Let's Code !                                         By I.A. |
   |                                                              |
   |*********************************************************************|
   |  LICENSE :                                                          |
   |                                                                     |
   |  DREAMLANDS_Z                                                       |
   |  Copyright (C) 2023 Sebastien SILVANO                               |
   |                                                                     |
   |  This library is free software; you can redistribute it and/or      |
   |  modify it under the terms of the GNU Lesser General Public         |
   |  License as published by the Free Software Foundation; either       |
   |  version 2.1 of the License, or (at your option) any later version. |
   |                                                                     |
   |  This library is distributed in the hope that it will be useful,    |
   |  but WITHOUT ANY WARRANTY; without even the implied warranty of     |
   |  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  |
   |  Lesser General Public License for more details.                    |
   |                                                                     |
   |  You should have received a copy of the GNU Lesser General Public   |
   |  License along with this library.                                   |
   |                                                                     |
   |  If not, see <https://www.gnu.org/licenses/>.                       |
   '---------------------------------------------------------------------'
*/






// ---------------- IMPORTATIONS ----------------

//errors
imp ../../errors

//charsets
imp ../../structure/string






// ---------------- MODULE ----------------

//module
mod Dreamlands {



	// ---- OPTIONS ----

	//allow additional spaces
	ADDITIONAL_SPACES_ALLOWED = true

	//debug mode
	DEBUG_MODE = false

	//allow external files importation (if false, importations will be skipped)
	EXTERNAL_IMPORTATIONS_ALLOWED = true

	//python character optimization (if true, python strings of 1 character long will be interpreted as characters)
	PYTHON_CHARACTERS_OPTIMIZATION = true // This is only applicable in function toText()






	// ---- CONSTANTS ----

	//blanks : DO NOT MODIFY
	BLANKS = (' ', '\t')






	// ---- CONSTANTS ----

	//special characters
	COMMENT_CHARACTER    = '#'
	LINE_END_CHARACTER   = '\n'
	NEW_FILE_CHARACTER   = '>'
	SEPARATION_CHARACTER = ':'
	TABULATION_CHARACTER = '\t'

	//keys
	KEYS_CHARACTERS_ALLOWED = ^Str.ALPHABET + '_' + ^Str.DIGITS

	//escaped characters (text elements)
	ESCAPED_CHARACTERS = :[
		'a' ='\a', 'b' ='\b', 'e' ='\e', 'f'='\f',
		'n' ='\n', 'r' ='\r', 't' ='\t', 'v'='\v',
		'\\'='\\', '\''='\'', '\"'='\"'
	}

	//some internal structures
	typ raw_instruct {
		int line_nbr, int colm_nbr,
		str raw_text,
		str chr_text, str str_text
	}
	typ instruct {
		int line_nbr, int colm_nbr,
		byt depth,
		str key,      atm value
	}






	// ---- GLOBAL DECLARATIONS ----

	//current index of instructs during unparsing
	instructsIndex = 0l






	// ---- DATA <-> TEXT ----

	//instructs display
	str ^.instruct.toStr() {
		ret "^Dreamlands.instruct{" + \
		typ.line_nbr.toStr() + ", " + \
		typ.colm_nbr.toStr() + ", " + \
		typ.depth.toStr()    + ", " + \
		typ.key              + ", " + \
		typ.value + "}"
	}
	str ^.raw_instruct.toStr() {
		ret "^Dreamlands.raw_instruct{" + \
		typ.line_nbr.toStr() + ", " + \
		typ.colm_nbr.toStr() + ", " + \
		typ.raw_text         + ", " + \
		typ.chr_text         + ", " + \
		typ.str_text + "}"
	}

	//error shortcut
	voi _checkChrSize(int line_nbr, int colm_nbr, str current_buffer) {
		if current_buffer.length != 0l {
			^Err.fatal(
				"Only one character is allowed in character declaration (line " + \
				line_nbr.toStr() + " column "                                   + \
				colm_nbr.toStr() + ")."
			)
		}
	}


	//data <- from text
	atm fromText(str text) {
		instructs = ^._textToInstructs(text) //get instruction list of current text

		//complete instruction set with external importations
		i = 0l
		importedFiles = []
		whi i < instructs.length {
			if ^.DEBUG_MODE {
				^IO.println("[DEBUG] Completing instructs : [" + i.toStr() + "] = " + instructs[i].toStr() + " len " + instructs.length.toStr())
			}

			//importation detected => add it to current instructs
			if instructs[i].depth < `00 {

				//anti-recursivity check
				if (instructs[i].value $ str) in importedFiles {
					^Err.fatal("Recursive importation detected : file '" + (instructs[i].value $ str) + "' already imported once.")
				}
				importedFiles + (instructs[i].value $ str)

				//read external file
				extText = ^IO.readFile(instructs[i].value)

				//get its instructions
				extIns = ^._textToInstructs(extText)

				//for each imported instruction
				for ei in extIns {
					instructs.insertBefore(i+ei, extIns[ei])
				}
				instructs.pop(i+extIns.length)
			}

			//increment (only on non-import instruction)
			els { ++i }
		}

		//no data
		if instructs.length == 0l {
			ret atm { 0s, null }
		}

		//check first element
		if instructs[0l].depth != `00 {
			^Err.fatal("Incorrect indent for first element : zero-depth is required.")
		}

		//check last element parentality
		if (instructs[-1l].value $ str).data == null {
			^Err.fatal("Incorrect value for last element : child element required.")
		}

		//debug
		if ^.DEBUG_MODE {
			^IO.println("[DEBUG] Completed instructs = [")
			for i ovr instructs {
				^IO.println("\t" + i.toStr() + ",")
			}
			^IO.println("]")
		}

		//finally translate instructions into data
		instructsIndex = 0l
		ret ^._instructsToData(instructs)
	}



	//parsing
	lst[^.instruct] _textToInstructs(str text) {

		// STEP 1 : SEPARATE INSTRUCTIONS

		//field detection
		inComment = false
		inChr     = false; inStr = false
		escaping  = false

		//just separate instructions
		raw_instructs = [
			^.raw_instruct { 1, 1, "", "", "" }
		]
		line_nbr = 1
		colm_nbr = 0
		for c in text {
			char = text[c]
			++colm_nbr
			if char == '\n' {
				++line_nbr
				colm_nbr  = 1
				inComment = false
			}

			//get latest raw_instruct location for error messages (optimization shortcut)
			latestRI_lineNbr = raw_instructs[-1l].line_nbr
			latestRI_colmNbr = raw_instructs[-1l].colm_nbr



			//case 1 : IN CHARACTER
			if inChr {

				//escaped sequences
				if escaping {
					^._checkChrLen(
						latestRI_lineNbr,
						latestRI_colmNbr,
						raw_instructs[-1l].chr_text
					)
					escaping = false
					if char in ^.ESCAPED_CHARACTERS.keys() {
						raw_instructs[-1l].chr_text + ^.ESCAPED_CHARACTERS[char]
					} els {
						^._invalidEscChr(latestRI_lineNbr, latestRI_colmNbr)
					}
				}

				//not escaping (reading normaly)
				els {

					//start escaping
					if char == '\\' { escaping = true }

					//end of text field detection
					elf char == '\'' { inChr = false }

					//regular character => add it
					els {
						^._checkChrLen(
							latestRI_lineNbr,
							latestRI_colmNbr,
							raw_instructs[-1l].chr_text
						)
						raw_instructs[-1l].chr_text + char
					}
				}
			}



			//case 2 : IN STRING
			elf inStr {

				//escaped sequences
				if escaping {
					escaping = false
					if char in ESCAPED_CHARACTERS.key() {
						raw_instructs[-1l].str_text += ^.ESCAPED_CHARACTERS[char]
					} els {
						^._invalidEscChr(latestRI_lineNbr, latestRI_colmNbr)
					}
				}

				//not escaping (reading normally)
				els {

					//start escaping
					if char == '\\' { escaping = true }

					//end of text field detection
					elf char == '\"' { inStr = false }

					//regular character => add it
					els { raw_instructs[-1l].str_text + char }
				}
			}



			//case 3 : RAW TEXT
			elf !inComment {

				//field detection : comment
				if char == ^.COMMENT_CHARACTER { inComment = true }

				//field detection : character
				elf char == '\'' {
					inChr = true

					//empty character (double character delimiter)
					if text.length > c+1 && text[c+1] == '\'' {
						^Err.fatal(
							"Empty characters are not supported (line " + \
							latestRI_lineNbr.toStr() + " column "       + \
							latestRI_colmNbr.toStr() + ")."
						)
					}
				}

				//field detection : string
				elf char == '\"' {
					inStr = true

					//empty string (double string delimiter)
					if text.length > c+1 && text[c+1] == '\"' {
						^Err.fatal(
							"Empty strings are not supported (line " + \
							latestRI_lineNbr.toStr() + " column "    + \
							latestRI_colmNbr.toStr() + ")."
						)
					}
				}

				//end of instruction => passing to the new one
				elf char == ^.LINE_END_CHARACTER {
					raw_instructs + ^.raw_instruct { line_nbr, colm_nbr, "", "", "" }
				}

				//add raw text to current instruction
				els { raw_instructs[-1l].raw_text + char }
			}
		}

		//missing text field delimiter
		if inChr {
			^Err.fatal(
				"Missing character delimiter at end of declaration (line " + \
				raw_instructs[-1l].line_nbr.toStr() + " column "           + \
				raw_instructs[-1l].colm_nbr.toStr() + ")."
			)
		}
		if inStr {
			^Err.fatal(
				"Missing string delimiter at end of declaration (line " + \
				raw_instructs[-1l].line_nbr.toStr() + " column "        + \
				raw_instructs[-1l].colm_nbr.toStr() + ")."
			)
		}

		//remove additional spaces (optional)
		if ^.ADDITIONAL_SPACES_ALLOWED {
			for a in raw_instructs {

				//remove spaces in raw_instructs[a].raw_text
				ri_rawText = ""
				for ovr in raw_instructs[a].raw_text {
					if c != ' ' { ri_rawText + c }
				}
				raw_instructs[a].raw_text = ri_rawText
			}
		}

		//debug
		if ^.DEBUG_MODE {
			^IO.println("[DEBUG] raw_instructs = [")
			for ri ovr raw_instructs {
				^IO.println("\t" + ri.toStr() + ",")
			}
			^IO.println("]")
		}



		// STEP 2 : SEPARATE FIELDS (inside each raw instruction)

		//instructions in strict format
		instructs = []

		//for each instruction
		for ri in raw_instructs:



			//phase 1 : PREPARATION & OBVIOUS CASES

			//empty instruction => skip it
			if ri.raw_text.length == 0l && ri.chr_text.length == 0l && ri.str_text.length == 0l { ctn }

			//both character & string declaration => NOT ALLOWED
			if ri.chr_text.length != 0l && ri.str_text.length != 0l {
				^Err.fatal(
					"Could not have both character and string declaration in only one instruction (line " + \
					ri.line_nbr.toStr() + " column "                                                      + \
					ri.colm_nbr.toStr() + ")."
				)
			}



			//phase 2 : IMPORTATIONS

			//importation detected
			if ri.raw_text.length != 0l && ri.raw_text[0] == ^.NEW_FILE_CHARACTER {

				//add it if option enabled
				if ^.EXTERNAL_IMPORTATIONS_ALLOWED {
					instructs + [
						ri.line_nbr,
						ri.colm_nbr,
						`ff,            //depth : negative means IMPORTATION FLAG
						0l,             //key
						ri.raw_text[1:] //value : here, filename is stored
					]
				}
				ctn //else : ignore this instruction
			}

			//not an importation => create a new empty instruction
			els {
				instructs + ^.instruct {
					ri.line_nbr,
					ri.colm_nbr,
					`00,          //depth
					"",           //key
					null          //value (null also means : PARENT)
				}
			}



			//phase 3 : ANALYSIS

			//set depth
			for c ovr ri.raw_text {
				if c == ^.TABULATION_CHARACTER {
					++(instructs[-1l].depth)
					ri.raw_text[1:] //cut the 1st character
				} els { brk }
			}

			//separate key-value pair
			pair = ri.raw_text.splitByChr(^.SEPARATION_CHARACTER)
			if pair.length != 2 {
				^Err.fatal(
					"One separation character is required per instruction (line " + \
					ri.line_nbr.toStr() + " column "                              + \
					ri.colm_nbr.toStr() + ")."
				)
			}
			instructs[-1l].key = pair[0l]
			value              = pair[1l]

			//check key name length
			if instructs[-1l].key.length == 0l {
				^Err.fatal(
					"Missing key name : at least one character is required (line " + \
					ri.line_nbr.toStr() + " column "                               + \
					ri.colm_nbr.toStr() + ")."
				)
			}

			//check key name
			if instructs[-1l].key != '-' {
				for c ovr instructs[-1l].key {
					if c !in ^.KEYS_CHARACTERS_ALLOWED {
						^Err.fatal(
							"Invalid character in key name : use only [a-z], [A-Z], [0-9] & underscores (line " + \
							ri.line_nbr.toStr() + " column "                                                    + \
							ri.colm_nbr.toStr() + ")."
						)
					}
				}
			}



			//case 1 : characters, strings or parent
			if value.length == 0l {

				//case 1.1 : character declaration
				if ri.chr_text.length != 0l { //can only be 0 or 1
					instructs[-1l].value = atm {
						atm.typ_chr,
						(ri[RI__CHR_TEXT] $ str)[0]
					}
				}

				//case 1.2 : string declaration
				elf ri.str_text.length != 0l {
					instructs[-1l]value = atm {
						atm.typ_str,
						ri.str_text
					}
				}

				//analysis terminated
				ctn
			}


			//case 2 : booleans
			if value == "false" {
				instructs[-1].value = atm { atm.typ_boo, false }; ctn
			}
			if value == "true" {
				instructs[-1].value = atm { atm.typ_boo, true }; ctn
			}



			//case 3 : numbers

			//negative values
			negative = false
			if value[0] == '-' {
				negative = true
				value = value[1:] //cut negative sign (performance optimization)
			}

			//check every character of value
			dotFound = false
			for v ovr value {
				if v == '.' {

					//dot already found => only one coma is allowed
					if dotFound {
						^Err.fatal(
							"Multiple dots found in floating point value for key '" + instructs[-1l].key + "' (line " + \
							ri.line_nbr.toStr() + " column "                                                          + \
							ri.colm_nbr.toStr() + ")."
						)
					}

					//1st dot found
					dotFound = true; ctn
				}

				//non-digit character => undefined value
				if v !in ^Str.DIGITS {
					^Err.fatal(
						"Undefined value for key '" + instructs[-1l].key + "' (line " + \
						ri.line_nbr + " column "                                      + \
						ri.colm_nbr + ")."
					)
				}
			}

			//floating point number
			if dotFound {
				instructs[-1].value = atm {
					atm.typ_flt,
					value.toFlt()
				}

			//integer
			els {
				instructs[-1][I__VALUE] = atm {
					atm.typ_int,
					value.toInt()
				}
			}

			//apply negativity afterwards
			if negative {
				instructs[-1l].value.data = -(instructs[-1l].value.data $ int)
			}

		//debug
		if ^.DEBUG_MODE {
			^IO.println("[DEBUG] instructs = [")
			for i in instructs {
				^IO.println("\t" + i.toStr() + ",")
			}
			^IO.println("]")
		}

		ret instructs
	}



	//translate intructions into data
	atm __getFullValue(lst[] instructs, int current_depth) {
		'''
		[INTERNAL FUNCTION] Get value of instruction even if it is a parent.
		This function is 2-times recursive with __instructsToData().

		instructs: list

		Returns data structure (list, dictionnary, or raw element).
		'''

		//get brother value : if parent, first process its children
		value = instructs[_.instructsIndex][I__VALUE]
		_.instructsIndex += 1
		if value is None:
			value = __instructsToData(instructs, current_depth+1)

		return value
	}

	atm __instructsToData(lst[] instructs, int current_depth=0) {
		'''
		[INTERNAL FUNCTION] Translates an instruction list into data structure.
		This function is 2-times recursive with __getFullValue().

		instructs: list

		Returns data structure (list or dictionnary).
		'''

		//1st instruction is a list element => global data will be a list
		data_isList = (instructs[_.instructsIndex][I__KEY] == '-')
		if data_isList:
			data = []
		else:
			data = {} //else, a dictionnary

		//for each instruction (mind that instructsIndex is NOT incremented in general scope of loop but in statements)
		instructs_len = len(instructs)
		while _.instructsIndex < instructs_len:

			//debug
			if DEBUG_MODE:
				print("[DEBUG] translating into data " + str(instructs[_.instructsIndex]) + "  instructsIndex " + str(_.instructsIndex) + ".")

			//case 1 : too much indent
			if instructs[_.instructsIndex][I__DEPTH] > current_depth+1:
				raise IndentationError(
					"Too much indent for instruct '" + instructs[_.instructsIndex][I__KEY] + "' (line " + \
					str(instructs[_.instructsIndex][I__LINE_NBR]) + " column "                          + \
					str(instructs[_.instructsIndex][I__COLM_NBR]) + ")."
				)

			//case 2 : child element
			elif instructs[_.instructsIndex][I__DEPTH] == current_depth+1:

				//children are processed by their parents (considerated as brothers between them)
				^Err.fatal(
					"Children element '" + instructs[_.instructsIndex][I__KEY] + "' detected but no parent declared (line " + \
					str(instructs[_.instructsIndex][I__LINE_NBR]) + " column "                                              + \
					str(instructs[_.instructsIndex][I__COLM_NBR]) + ")."
				)

			//case 3 : brother element
			elif instructs[_.instructsIndex][I__DEPTH] == current_depth:

				//list element (brothers must be of the same kind)
				if data_isList:
					if instructs[_.instructsIndex][I__KEY] != '-':
						^Err.fatal(
							"Key name '" + instructs[_.instructsIndex][I__KEY] + "' detected inside a list (line " + \
							str(instructs[_.instructsIndex][I__LINE_NBR]) + " column "                             + \
							str(instructs[_.instructsIndex][I__COLM_NBR]) + ")."
						)

					//add brother element next to the current one
					data.append( __getFullValue(instructs, current_depth) )

				//non-list element (brothers must be of the same kind)
				else:
					if instructs[_.instructsIndex][I__KEY] == '-':
						^Err.fatal(
							"List element detected outside a list (line "              + \
							str(instructs[_.instructsIndex][I__LINE_NBR]) + " column " + \
							str(instructs[_.instructsIndex][I__COLM_NBR]) + ")."
						)
					key = instructs[_.instructsIndex][I__KEY]

					//check key before adding brother
					if key in data.keys():
						^Err.fatal(
							"Key '" + key + "' already defined in its parent (line "   + \
							str(instructs[_.instructsIndex][I__LINE_NBR]) + " column " + \
							str(instructs[_.instructsIndex][I__COLM_NBR]) + ")."
						)

					//add brother element next to the current one (get value even recursively)
					data[key] = __getFullValue(instructs, current_depth)

			//case 4 : brother element of a parent (an uncle / grand-uncle / ...) => not of our business (end of child block)
			else:
				return data

		return data
	}



	//data -> to text
	str __elementToText(atm elem, int depth) {
		'''
		[INTERNAL FUNCTION] Convert a data element into DREAMLANDS text.
		This function is recursive.

		data: dict, tuple, list
		depth: int

		Returns a chunk of DREAMLANDS text corresponding to the given data.
		'''
		newDepth = depth+1

		//case 1: [PARENT] element is a dictionnary
		if isinstance(elem, dict):
			text = LINE_END_CHARACTER
			for k in elem.keys():
				text += newDepth*TABULATION_CHARACTER + k + SEPARATION_CHARACTER + __elementToText(elem[k], newDepth)
			return text

		//case 2: [PARENT] element is a tuple/list
		elif isinstance(elem, tuple) or isinstance(elem, list):
			text = LINE_END_CHARACTER
			for e in elem:
				text += newDepth*TABULATION_CHARACTER + '-' + SEPARATION_CHARACTER + __elementToText(e, newDepth)
			return text

		//case 3: [CHILD] element is standalone
		elif elem is not None:

			//special case 3.1: boolean
			if isinstance(elem, bool):
				if elem:
					return "true" + LINE_END_CHARACTER
				return "false" + LINE_END_CHARACTER

			//special case 3.2: strings
			elif isinstance(elem, str):

				//python characters optimization
				if PYTHON_CHARACTERS_OPTIMIZATION:
					if len(elem) == 1:
						return "\'" + str(elem) + "\'" + LINE_END_CHARACTER
				return "\"" + str(elem) + "\"" + LINE_END_CHARACTER

			//regular case 3.3: other [integer (including negative sign), floating point number (including negative sign)]
			return str(elem) + LINE_END_CHARACTER

		//case 4: element is None => ERROR
		else:
			^Err.fatal("Unable to parse DREAMLANDS text, data contains None value(s).")
	}

	str toText(atm data) {
		'''
		Convert a data structure into DREAMLANDS text.

		data: dict, tuple, list

		Returns a DREAMLANDS text corresponding to the given data.
		'''

		//check structure type
		if not isinstance(data, dict) and not isinstance(data, tuple) and not isinstance(data, list):
			^Err.fatal("Could not parse DREAMLANDS text, data has incorrect type (dict, tuple or list allowed).")

		//parse data
		return __elementToText(data, -1)[1:] //skip 1st character (useless LINE_END_CHARACTER in global context)
	}






	// ---- READ / WRITE ----

	//read text from file => return data as dict
	atm read(str filename) {
		'''
		Read a DREAMLANDS file.

		filename: str

		Returns a dictionnary representing the data read from the file.
		'''

		//read text from file
		f = open(filename, "r")
		text = f.read()
		f.close()

		//parse
		return fromText(text)
	}



	//write data into file
	voi write(str filename, atm data) {
		'''
		Write data into a DREAMLANDS file.

		data: dict
		filename: str

		Write the data respecting the DREAMLANDS syntax.
		'''

		//unparse
		text = toText(data)

		//write out
		f = open(filename, "w")
		f.write(text)
		f.close()
	}
}
