/* .----------------- DREAMLANDS Z Library [0.1.0] ---------------.
   |                                                              |
   |     This library is the official parser tool for DREAMLANDS  |
   | files. It includes 4 functions :                             |
   |   - Dreamlands.fromText() get data from raw text             |
   |   - Dreamlands.toText()   get raw text from data             |
   |   - Dreamlands.read()     get data from file                 |
   |   - Dreamlands.write()    write data into file               |
   |                                                              |
   |     For more information about this syntax, please check     |
   | out the main repository for documentation:                   |
   |                                                              |
   |           https://github.com/iasebsil83/DREAMLANDS           |
   |                                                              |
   | Let's Code !                                         By I.A. |
   |                                                              |
   |*********************************************************************|
   |  LICENSE :                                                          |
   |                                                                     |
   |  DREAMLANDS_Z                                                       |
   |  Copyright (C) 2023 Sebastien SILVANO                               |
   |                                                                     |
   |  This library is free software; you can redistribute it and/or      |
   |  modify it under the terms of the GNU Lesser General Public         |
   |  License as published by the Free Software Foundation; either       |
   |  version 2.1 of the License, or (at your option) any later version. |
   |                                                                     |
   |  This library is distributed in the hope that it will be useful,    |
   |  but WITHOUT ANY WARRANTY; without even the implied warranty of     |
   |  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  |
   |  Lesser General Public License for more details.                    |
   |                                                                     |
   |  You should have received a copy of the GNU Lesser General Public   |
   |  License along with this library.                                   |
   |                                                                     |
   |  If not, see <https://www.gnu.org/licenses/>.                       |
   '---------------------------------------------------------------------'
*/






// ---------------- IMPORTATIONS ----------------

//errors
imp ../../errors

//charsets
imp ../../structure/string






// ---------------- MODULE ----------------

//module
mod Dreamlands {



	// ---- OPTIONS ----

	//allow additional spaces
	ADDITIONAL_SPACES_ALLOWED = true

	//debug mode
	DEBUG_MODE = false

	//allow external files importation (if false, importations will be skipped)
	EXTERNAL_IMPORTATIONS_ALLOWED = true






	// ---- CONSTANTS ----

	//blanks : DO NOT MODIFY
	BLANKS = (' ', '\t')






	// ---- CONSTANTS ----

	//special characters
	COMMENT_CHARACTER    = '#'
	LINE_END_CHARACTER   = '\n'
	NEW_FILE_CHARACTER   = '>'
	SEPARATION_CHARACTER = ':'
	TABULATION_CHARACTER = '\t'

	//keys
	KEYS_CHARACTERS_ALLOWED = ^Str.ALPHABET + '_' + ^Str.DIGITS

	//escaped characters (text elements)
	ESCAPED_CHARACTERS = :[
		'a' ='\a', 'b' ='\b', 'e' ='\e', 'f'='\f',
		'n' ='\n', 'r' ='\r', 't' ='\t', 'v'='\v',
		'\\'='\\', '\''='\'', '\"'='\"'
	}

	//some internal structures
	typ raw_instruct {
		int line_nbr, int colm_nbr,
		str raw_text,
		str chr_text, str str_text
	}
	typ instruct {
		int line_nbr, int colm_nbr,
		byt depth,
		str key,      atm value
	}






	// ---- GLOBAL DECLARATIONS ----

	//current index of instructs during unparsing
	instructsIndex = 0l






	// ---- DATA <-> TEXT ----

	//instructs display
	str ^.instruct.toStr() {
		ret "^Dreamlands.instruct{" + \
		typ.line_nbr.toStr() + ", " + \
		typ.colm_nbr.toStr() + ", " + \
		typ.depth.toStr()    + ", " + \
		typ.key              + ", " + \
		typ.value + "}"
	}
	str ^.raw_instruct.toStr() {
		ret "^Dreamlands.raw_instruct{" + \
		typ.line_nbr.toStr() + ", " + \
		typ.colm_nbr.toStr() + ", " + \
		typ.raw_text         + ", " + \
		typ.chr_text         + ", " + \
		typ.str_text + "}"
	}

	//error shortcut
	voi _checkChrSize(int line_nbr, int colm_nbr, str current_buffer) {
		if current_buffer.length != 0l {
			^Err.fatal(
				"Only one character is allowed in character declaration (line " + \
				line_nbr.toStr() + " column "                                   + \
				colm_nbr.toStr() + ")."
			)
		}
	}


	//data <- from text
	atm fromText(str text) {
		instructs = ^._textToInstructs(text) //get instruction list of current text

		//complete instruction set with external importations
		i = 0l
		importedFiles = []
		whi i < instructs.length {
			if ^.DEBUG_MODE {
				^IO.println("[DEBUG] Completing instructs : [" + i.toStr() + "] = " + instructs[i].toStr() + " len " + instructs.length.toStr())
			}

			//importation detected => add it to current instructs
			if instructs[i].depth < `00 {

				//anti-recursivity check
				if (instructs[i].value.data $ str) in importedFiles {
					^Err.fatal("Recursive importation detected : file '" + (instructs[i].value $ str) + "' already imported once.")
				}
				importedFiles + (instructs[i].value.data $ str)

				//read external file
				extText = ^IO.readFile(instructs[i].value)

				//get its instructions
				extIns = ^._textToInstructs(extText)

				//for each imported instruction
				for ei in extIns {
					instructs.insertBefore(i+ei, extIns[ei])
				}
				instructs.pop(i+extIns.length)
			}

			//increment (only on non-import instruction)
			els { ++i }
		}

		//no data
		if instructs.length == 0l {
			ret atm { atm.typ_ptr, null }
		}

		//check first element
		if instructs[0l].depth != `00 {
			^Err.fatal("Incorrect indent for first element : zero-depth is required.")
		}

		//check last element parentality
		if instructs[-1l].value.data == null {
			^Err.fatal("Incorrect value for last element : child element required.")
		}

		//debug
		if ^.DEBUG_MODE {
			^IO.println("[DEBUG] Completed instructs = [")
			for i ovr instructs {
				^IO.println("\t" + i.toStr() + ",")
			}
			^IO.println("]")
		}

		//finally translate instructions into data
		^.instructsIndex = 0l
		ret ^._instructsToData(instructs)
	}



	//parsing
	lst[^.instruct] _textToInstructs(str text) {

		// STEP 1 : SEPARATE INSTRUCTIONS

		//field detection
		inComment = false
		inChr     = false; inStr = false
		escaping  = false

		//just separate instructions
		raw_instructs = [
			^.raw_instruct { 1, 1, "", "", "" }
		]
		line_nbr = 1
		colm_nbr = 0
		for c in text {
			char = text[c]
			++colm_nbr
			if char == '\n' {
				++line_nbr
				colm_nbr  = 1
				inComment = false
			}

			//get latest raw_instruct location for error messages (optimization shortcut)
			latestRI_lineNbr = raw_instructs[-1l].line_nbr
			latestRI_colmNbr = raw_instructs[-1l].colm_nbr



			//case 1 : IN CHARACTER
			if inChr {

				//escaped sequences
				if escaping {
					^._checkChrLen(
						latestRI_lineNbr,
						latestRI_colmNbr,
						raw_instructs[-1l].chr_text
					)
					escaping = false
					if char in ^.ESCAPED_CHARACTERS.keys {
						raw_instructs[-1l].chr_text + ^.ESCAPED_CHARACTERS[char]
					} els {
						^._invalidEscChr(latestRI_lineNbr, latestRI_colmNbr)
					}
				}

				//not escaping (reading normaly)
				els {

					//start escaping
					if char == '\\' { escaping = true }

					//end of text field detection
					elf char == '\'' { inChr = false }

					//regular character => add it
					els {
						^._checkChrLen(
							latestRI_lineNbr,
							latestRI_colmNbr,
							raw_instructs[-1l].chr_text
						)
						raw_instructs[-1l].chr_text + char
					}
				}
			}



			//case 2 : IN STRING
			elf inStr {

				//escaped sequences
				if escaping {
					escaping = false
					if char in ESCAPED_CHARACTERS.keys {
						raw_instructs[-1l].str_text += ^.ESCAPED_CHARACTERS[char]
					} els {
						^._invalidEscChr(latestRI_lineNbr, latestRI_colmNbr)
					}
				}

				//not escaping (reading normally)
				els {

					//start escaping
					if char == '\\' { escaping = true }

					//end of text field detection
					elf char == '\"' { inStr = false }

					//regular character => add it
					els { raw_instructs[-1l].str_text + char }
				}
			}



			//case 3 : RAW TEXT
			elf !inComment {

				//field detection : comment
				if char == ^.COMMENT_CHARACTER { inComment = true }

				//field detection : character
				elf char == '\'' {
					inChr = true

					//empty character (double character delimiter)
					if text.length > c+1 && text[c+1] == '\'' {
						^Err.fatal(
							"Empty characters are not supported (line " + \
							latestRI_lineNbr.toStr() + " column "       + \
							latestRI_colmNbr.toStr() + ")."
						)
					}
				}

				//field detection : string
				elf char == '\"' {
					inStr = true

					//empty string (double string delimiter)
					if text.length > c+1 && text[c+1] == '\"' {
						^Err.fatal(
							"Empty strings are not supported (line " + \
							latestRI_lineNbr.toStr() + " column "    + \
							latestRI_colmNbr.toStr() + ")."
						)
					}
				}

				//end of instruction => passing to the new one
				elf char == ^.LINE_END_CHARACTER {
					raw_instructs + ^.raw_instruct { line_nbr, colm_nbr, "", "", "" }
				}

				//add raw text to current instruction
				els { raw_instructs[-1l].raw_text + char }
			}
		}

		//missing text field delimiter
		if inChr {
			^Err.fatal(
				"Missing character delimiter at end of declaration (line " + \
				raw_instructs[-1l].line_nbr.toStr() + " column "           + \
				raw_instructs[-1l].colm_nbr.toStr() + ")."
			)
		}
		if inStr {
			^Err.fatal(
				"Missing string delimiter at end of declaration (line " + \
				raw_instructs[-1l].line_nbr.toStr() + " column "        + \
				raw_instructs[-1l].colm_nbr.toStr() + ")."
			)
		}

		//remove additional spaces (optional)
		if ^.ADDITIONAL_SPACES_ALLOWED {
			for a in raw_instructs {

				//remove spaces in raw_instructs[a].raw_text
				ri_rawText = ""
				for ovr in raw_instructs[a].raw_text {
					if c != ' ' { ri_rawText + c }
				}
				raw_instructs[a].raw_text = ri_rawText
			}
		}

		//debug
		if ^.DEBUG_MODE {
			^IO.println("[DEBUG] raw_instructs = [")
			for ri ovr raw_instructs {
				^IO.println("\t" + ri.toStr() + ",")
			}
			^IO.println("]")
		}



		// STEP 2 : SEPARATE FIELDS (inside each raw instruction)

		//instructions in strict format
		instructs = []

		//for each instruction
		for ri in raw_instructs:



			//phase 1 : PREPARATION & OBVIOUS CASES

			//empty instruction => skip it
			if ri.raw_text.length == 0l && ri.chr_text.length == 0l && ri.str_text.length == 0l { ctn }

			//both character & string declaration => NOT ALLOWED
			if ri.chr_text.length != 0l && ri.str_text.length != 0l {
				^Err.fatal(
					"Could not have both character and string declaration in only one instruction (line " + \
					ri.line_nbr.toStr() + " column "                                                      + \
					ri.colm_nbr.toStr() + ")."
				)
			}



			//phase 2 : IMPORTATIONS

			//importation detected
			if ri.raw_text.length != 0l && ri.raw_text[0] == ^.NEW_FILE_CHARACTER {

				//add it if option enabled
				if ^.EXTERNAL_IMPORTATIONS_ALLOWED {
					instructs + [
						ri.line_nbr,
						ri.colm_nbr,
						`ff,            //depth : negative means IMPORTATION FLAG
						0l,             //key
						ri.raw_text[1:] //value : here, filename is stored
					]
				}
				ctn //else : ignore this instruction
			}

			//not an importation => create a new empty instruction
			els {
				instructs + ^.instruct {
					ri.line_nbr,
					ri.colm_nbr,
					`00,                      //depth
					"",                       //key
					atm { atm.typ_ptr, null } //value (also means : PARENT)
				}
			}



			//phase 3 : ANALYSIS

			//set depth
			for c ovr ri.raw_text {
				if c == ^.TABULATION_CHARACTER {
					++(instructs[-1l].depth)
					ri.raw_text[1:] //cut the 1st character
				} els { brk }
			}

			//separate key-value pair
			pair = ri.raw_text.splitByChr(^.SEPARATION_CHARACTER)
			if pair.length != 2 {
				^Err.fatal(
					"One separation character is required per instruction (line " + \
					ri.line_nbr.toStr() + " column "                              + \
					ri.colm_nbr.toStr() + ")."
				)
			}
			instructs[-1l].key = pair[0l]
			value              = pair[1l]

			//check key name length
			if instructs[-1l].key.length == 0l {
				^Err.fatal(
					"Missing key name : at least one character is required (line " + \
					ri.line_nbr.toStr() + " column "                               + \
					ri.colm_nbr.toStr() + ")."
				)
			}

			//check key name
			if instructs[-1l].key != '-' {
				for c ovr instructs[-1l].key {
					if c !in ^.KEYS_CHARACTERS_ALLOWED {
						^Err.fatal(
							"Invalid character in key name : use only [a-z], [A-Z], [0-9] & underscores (line " + \
							ri.line_nbr.toStr() + " column "                                                    + \
							ri.colm_nbr.toStr() + ")."
						)
					}
				}
			}



			//case 1 : characters, strings or parent
			if value.length == 0l {

				//case 1.1 : character declaration
				if ri.chr_text.length != 0l { //can only be 0 or 1
					instructs[-1l].value = atm {
						atm.typ_chr,
						ri.chr_text[0]
					}
				}

				//case 1.2 : string declaration
				elf ri.str_text.length != 0l {
					instructs[-1l].value = atm {
						atm.typ_str,
						ri.str_text
					}
				}

				//analysis terminated
				ctn
			}


			//case 2 : booleans
			if value == "false" {
				instructs[-1].value = atm { atm.typ_boo, false }; ctn
			}
			if value == "true" {
				instructs[-1].value = atm { atm.typ_boo, true }; ctn
			}



			//case 3 : numbers

			//negative values
			negative = false
			if value[0] == '-' {
				negative = true
				value[1:] //cut negative sign (performance optimization)
			}

			//check every character of value
			dotFound = false
			for v ovr value {
				if v == '.' {

					//dot already found => only one coma is allowed
					if dotFound {
						^Err.fatal(
							"Multiple dots found in floating point value for key '" + instructs[-1l].key + "' (line " + \
							ri.line_nbr.toStr() + " column "                                                          + \
							ri.colm_nbr.toStr() + ")."
						)
					}

					//1st dot found
					dotFound = true; ctn
				}

				//non-digit character => undefined value
				if v !in ^Str.DIGITS {
					^Err.fatal(
						"Undefined value for key '" + instructs[-1l].key + "' (line " + \
						ri.line_nbr.toStr() + " column "                              + \
						ri.colm_nbr.toStr() + ")."
					)
				}
			}

			//floating point number
			if dotFound {
				instructs[-1l].value = atm {
					atm.typ_flt,
					value.toFlt()
				}

			//integer
			els {
				instructs[-1l].value = atm {
					atm.typ_int,
					value.toInt()
				}
			}

			//apply negativity afterwards
			if negative {
				instructs[-1l].value.data = -(instructs[-1l].value.data $ int)
			}

		//debug
		if ^.DEBUG_MODE {
			^IO.println("[DEBUG] instructs = [")
			for i ovr instructs {
				^IO.println("\t" + i.toStr() + ",")
			}
			^IO.println("]")
		}

		ret instructs
	}



	//translate intructions into data
	atm _getFullValue(lst[^.instruct] instructs, int current_depth) { //2-times recursive with ^._instructsToData().

		//get brother value : if parent, first process its children
		value = instructs[^.instructsIndex].value
		++^.instructsIndex
		if value.type = 0l {
			value = ^._instructsToData(instructs, current_depth+1)
		}

		ret value
	}

	atm _instructsToData(lst[^.instruct] instructs, int current_depth=0) { //2-times recursive with ^._getFullValue().

		//1st instruction is a list element => global data will be a list
		data_isList = instructs[^.instructsIndex].key == '-'
		if data_isList {
			data = atm { atm.typ_lst,  [] }
		} els {
			data = atm { atm.typ_map, :[] } //else, a map[str,atm]
		}

		//for each instruction (mind that ^.instructsIndex is NOT incremented in general scope of loop but in statements)
		whi ^.instructsIndex < instructs.length {

			//debug
			if ^.DEBUG_MODE {
				^IO.println("[DEBUG] translating into data " + instructs[^.instructsIndex].toStr() + "  instructsIndex " + ^.instructsIndex.toStr() + ".")
			}

			//case 1 : too much indent
			if instructs[^.instructsIndex].depth > current_depth+1 {
				^Err.fatal(
					"Too much indent for instruct '" + instructs[^.instructsIndex].key + "' (line " + \
					instructs[^.instructsIndex].line_nbr.toStr() + " column "                       + \
					instructs[^.instructsIndex].colm_nbr.toStr() + ")."
				)
			}

			//case 2 : child element
			elf instructs[^.instructsIndex].depth == current_depth+1 {

				//children are processed by their parents (considerated as brothers between them)
				^Err.fatal(
					"Children element '" + instructs[^.instructsIndex].key + "' detected but no parent declared (line " + \
					instructs[^.instructsIndex].line_nbr.toStr() + " column "                                           + \
					instructs[^.instructsIndex].colm_nbr.toStr() + ")."
				)
			}

			//case 3 : brother element
			elf instructs[^.instructsIndex].depth == current_depth {

				//list element (brothers must be of the same kind)
				if data_isList {
					if instructs[^.instructsIndex].key != '-' {
						^Err.fatal(
							"Key name '" + instructs[^.instructsIndex].key + "' detected inside a list (line " + \
							instructs[^.instructsIndex].line_nbr.toStr() + " column "                          + \
							instructs[^.instructsIndex].colm_nbr.toStr() + ")."
						)
					}

					//add brother element next to the current one
					(data.data $ lst) + ^._getFullValue(instructs, current_depth)
				}

				//non-list element (brothers must be of the same kind)
				els {
					if instructs[^.instructsIndex].key == '-' {
						^Err.fatal(
							"List element detected outside a list (line "             + \
							instructs[^.instructsIndex].line_nbr.toStr() + " column " + \
							instructs[^.instructsIndex].colm_nbr.toStr() + ")."
						)
					}
					key = instructs[^.instructsIndex].key

					//check key before adding brother
					if key in (data.data $ map).keys {
						^Err.fatal(
							"Key '" + key + "' already defined in its parent (line "  + \
							instructs[^.instructsIndex].line_nbr.toStr() + " column " + \
							instructs[^.instructsIndex].colm_nbr.toStr() + ")."
						)
					}

					//add brother element next to the current one (get value even recursively)
					(data.data $ map)[key] = ^._getFullValue(instructs, current_depth)
				}
			}

			//case 4 : brother element of a parent (an uncle / grand-uncle / ...) => not of our business (end of child block)
			els { ret data }
		}

		ret data
	}



	//data -> to text
	str ^._elementToText(atm elem, int depth) { //recursive
		newDepth = depth+1
		swi elem.type {

			//map [PARENT]
			atm.typ_map {
				text = ^.LINE_END_CHARACTER
				for k ovr (elem.data $ map).keys {
					text += newDepth * ^.TABULATION_CHARACTER + k + ^.SEPARATION_CHARACTER + ^._elementToText(elem.data$lst[k], newDepth)
				}
				ret text
			}

			//list [PARENT]
			atm.typ_lst {
				text = ^.LINE_END_CHARACTER
				for e ovr elem.data$lst {
					text += newDepth * ^.TABULATION_CHARACTER + '-' + ^.SEPARATION_CHARACTER + ^._elementToText(e, newDepth)
				}
				ret text
			}

			//boolean [CHILD]
			atm.typ_boo {
				if elem.data$boo { ret "true"  + ^.LINE_END_CHARACTER }
				                   ret "false" + ^.LINE_END_CHARACTER
			}

			//strings [CHILD]
			atm.typ_str {
				ret '\"' + (elem.data$str) + '\"' + ^.LINE_END_CHARACTER
			}

			//long integer [CHILD]
			atm.typ_lng {
				ret (elem.data$lng).toStr() + ^.LINE_END_CHARACTER
			}

			//double floating point [CHILD]
			atm.typ_dbl {
				ret (elem.data$dbl).toStr() + ^.LINE_END_CHARACTER
			}

			//unauthorized type
			def {
				^Err.fatal("Unable to generate DREAMLANDS text, data contains unauthorized types.")
			}
		}
	}

	str toText(atm data) {

		//check structure type
		if data.type != atm.typ_map && data.type != atm.typ_lst {
			^Err.fatal("Could not generate DREAMLANDS text, data has incorrect type (map or lst allowed only).")
		}

		//parse data
		ret ^._elementToText(data, -1)[1:] //skip 1st character (useless LINE_END_CHARACTER in global context)
	}






	// ---- READ / WRITE ----

	//read text from file => return data as atm
	atm read(str filename) {
		ret ^.fromText(^IO.readFile(filename))
	}



	//write data into file
	voi write(str filename, atm data) {
		^IO.writeFile(filename, ^.toText(data))
	}
}
